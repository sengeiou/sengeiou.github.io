<!DOCTYPE html>
<!-- saved from url=(0053)http://127.0.0.1:4000/2018/05/19/android-process-adj/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="gityuan">
    <meta name="keyword" content="Android,Gityuan,Android技术博客,Android源码分析,袁辉辉">
    <meta name="description" content="Android,Gityuan,Android技术博客,Android源码分析,袁辉辉">
    <meta name="baidu-site-verification" content="tgshRgudx0">
    <link rel="shortcut icon" href="http://127.0.0.1:4000/images/favicon.ico">
    <title>解读Android进程优先级ADJ算法 - Gityuan博客 | 袁辉辉博客</title>

    <link rel="canonical" href="http://gityuan.com/2018/05/19/android-process-adj/">

    <!-- Bootstrap Core CSS -->
    <style class="anchorjs"></style><link rel="stylesheet" href="./解读Android进程优先级ADJ算法 - Gityuan博客 _ 袁辉辉博客_files/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="./解读Android进程优先级ADJ算法 - Gityuan博客 _ 袁辉辉博客_files/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="./解读Android进程优先级ADJ算法 - Gityuan博客 _ 袁辉辉博客_files/syntax.css">

    <!-- Custom Fonts -->
    <!-- change font-awesome CDN to qiniu -->
    <link href="./解读Android进程优先级ADJ算法 - Gityuan博客 _ 袁辉辉博客_files/font-awesome.min.css" rel="stylesheet" type="text/css">
    
    <!-- add highlight -->
    <link rel="stylesheet" href="./解读Android进程优先级ADJ算法 - Gityuan博客 _ 袁辉辉博客_files/androidstudio.css">
		<script src="./解读Android进程优先级ADJ算法 - Gityuan博客 _ 袁辉辉博客_files/jquery.nav.js"></script><script src="./解读Android进程优先级ADJ算法 - Gityuan博客 _ 袁辉辉博客_files/fastclick.min.js"></script><script src="./解读Android进程优先级ADJ算法 - Gityuan博客 _ 袁辉辉博客_files/anchor.min.js"></script><script type="text/javascript" src="./解读Android进程优先级ADJ算法 - Gityuan博客 _ 袁辉辉博客_files/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
		
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top is-fixed">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://127.0.0.1:4000/">Gityuan</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar" class=" ">
            <div class="navbar-collapse" style="height: 0px;">
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://127.0.0.1:4000/">home</a></li>
                    <li><a href="http://127.0.0.1:4000/about">About</a></li>
                    <li><a href="http://127.0.0.1:4000/talk">talk</a></li>
                    <li><a href="http://127.0.0.1:4000/archive">Archive</a></li>
                    <li><a href="http://127.0.0.1:4000/tags">Tags</a></li>
                    <li><a href="http://127.0.0.1:4000/friends">Friends</a></li>
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/nav-home.jpg" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/nav-home.jpg')
    }

    
</style>
<header class="intro-header">
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a target="_blank" class="tag" href="http://127.0.0.1:4000/tags/#android" title="android">android</a>
                        
                    </div>
                    <h1 id="androidadj">解读Android进程优先级ADJ算法</h1>
                    
                    
                    <h2 class="subheading" id=""></h2>
                    
                    <span class="meta">Posted by Gityuan on May 19, 2018</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

								<p>本文基于Android P源码来解读进程优先级原理，基于篇幅考虑会精炼部分代码</p>

<h2 id="section">一、概述<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#section" aria-label="Anchor link for: section" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h2>

<h3 id="section-1">1.1 进程<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#section-1" aria-label="Anchor link for: section 1" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<p>Android框架对进程创建与管理进行了封装，对于APP开发者只需知道Android四大组件的使用。当Activity, Service, ContentProvider, BroadcastReceiver任一组件启动时，当其所承载的进程存在则直接使用，不存在则由框架代码自动调用startProcessLocked创建进程。一个APP可以拥有多个进程，多个APP也可以运行在同一个进程，通过配置Android:process属性来决定。所以说对APP来说进程几乎是透明的，但了解进程对于深刻理解Android系统还是非常关键的。</p>

<h3 id="section-2">1.2 优先级<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#section-2" aria-label="Anchor link for: section 2" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<p>应用首次打开比较慢，这个过程有进程创建以及Application等信息的初始化，故应用启动后退到后台并非立刻杀死，而是存活一段时间，这样下次再使用则会非常快速地打开。Android系统的设计理念正是希望应用进程能尽量长时间地存活，以提升用户体验。对于APP来说都希望自身尽可能存活更长的时间，甚至探索各种保活黑科技。倘若系统放任所有进程一直存活，系统内存很快就会枯竭而亡，在系统处于低内存的状态下，手机性能会有所下降，那么需要合理地进程回收机制。</p>

<p>到底该回收哪个进程呢？系统根据进程的组件状态来决定每个进程的优先级值ADJ，系统根据一定策略先杀优先级最低的进程，然后逐步杀优先级更低的进程，依此类推，以回收预期的可用系统资源，从而保证系统正常运转。</p>

<p>谈到优先级，可能有些人会想到Linux进程本身有nice值，这个会影响CPU资源调度的优先级；而本文介绍Android框架层中的ADJ，主要是影响进程在什么场景下可能会被杀，跟进程的存活时间有关；要区分两者定位的不同，当然ADJ与nice其实也有一定的联系。可想而知，往往优先级很高的进程，也是不希望被杀的进程，是有一定地正相关性。</p>

<h3 id="adj">1.3 ADJ级别<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#adj" aria-label="Anchor link for: adj" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<div class="table-responsive"><table class="table">
  <thead>
    <tr>
      <th>ADJ级别</th>
      <th style="text-align: left">取值</th>
      <th style="text-align: left">含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>NATIVE_ADJ</td>
      <td style="text-align: left">-1000</td>
      <td style="text-align: left">native进程</td>
    </tr>
    <tr>
      <td>SYSTEM_ADJ</td>
      <td style="text-align: left">-900</td>
      <td style="text-align: left">仅指system_server进程</td>
    </tr>
    <tr>
      <td>PERSISTENT_PROC_ADJ</td>
      <td style="text-align: left">-800</td>
      <td style="text-align: left">系统persistent进程</td>
    </tr>
    <tr>
      <td>PERSISTENT_SERVICE_ADJ</td>
      <td style="text-align: left">-700</td>
      <td style="text-align: left">关联着系统或persistent进程</td>
    </tr>
    <tr>
      <td>FOREGROUND_APP_ADJ</td>
      <td style="text-align: left">0</td>
      <td style="text-align: left">前台进程</td>
    </tr>
    <tr>
      <td>VISIBLE_APP_ADJ</td>
      <td style="text-align: left">100</td>
      <td style="text-align: left">可见进程</td>
    </tr>
    <tr>
      <td>PERCEPTIBLE_APP_ADJ</td>
      <td style="text-align: left">200</td>
      <td style="text-align: left">可感知进程，比如后台音乐播放</td>
    </tr>
    <tr>
      <td>BACKUP_APP_ADJ</td>
      <td style="text-align: left">300</td>
      <td style="text-align: left">备份进程</td>
    </tr>
    <tr>
      <td>HEAVY_WEIGHT_APP_ADJ</td>
      <td style="text-align: left">400</td>
      <td style="text-align: left">重量级进程</td>
    </tr>
    <tr>
      <td>SERVICE_ADJ</td>
      <td style="text-align: left">500</td>
      <td style="text-align: left">服务进程</td>
    </tr>
    <tr>
      <td>HOME_APP_ADJ</td>
      <td style="text-align: left">600</td>
      <td style="text-align: left">Home进程</td>
    </tr>
    <tr>
      <td>PREVIOUS_APP_ADJ</td>
      <td style="text-align: left">700</td>
      <td style="text-align: left">上一个进程</td>
    </tr>
    <tr>
      <td>SERVICE_B_ADJ</td>
      <td style="text-align: left">800</td>
      <td style="text-align: left">B List中的Service</td>
    </tr>
    <tr>
      <td>CACHED_APP_MIN_ADJ</td>
      <td style="text-align: left">900</td>
      <td style="text-align: left">不可见进程的adj最小值</td>
    </tr>
    <tr>
      <td>CACHED_APP_MAX_ADJ</td>
      <td style="text-align: left">906</td>
      <td style="text-align: left">不可见进程的adj最大值</td>
    </tr>
  </tbody>
</table></div>

<p>Android 7.0之前的版本，ADJ采用数字1、2、3…；从Android 7.0开始，ADJ采用100、200、300…。
这样调整有两个好处：</p>

<ul>
  <li>更进一步地细化进程的优先级，比如在原有的VISIBLE_APP_ADJ(100)与PERCEPTIBLE_APP_ADJ(200)之间，可以有ADJ=101的进程。</li>
  <li>省去lmk对oom_score_adj的计算过程，Android 7.0之前的版本，oom_score_adj= oom_adj * 1000/17；
而Android 7.0开始，oom_score_adj= oom_adj，不用再经过一次转换。</li>
</ul>

<h2 id="adj-1">二、解读ADJ<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#adj-1" aria-label="Anchor link for: adj 1" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h2>

<p>接下来，解读每一个ADJ值都对应着怎样条件的进程，包括正在运行的组件以及这些组件的状态几何。</p>

<h3 id="nativeadj-1000">2.1 NATIVE_ADJ(-1000)<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#nativeadj-1000" aria-label="Anchor link for: nativeadj 1000" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<p>Native进程作为特殊进程，并不受system管控，故其oom adj不是由system赋值。</p>

<h3 id="systemadj-900">2.2 SYSTEM_ADJ(-900)<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#systemadj-900" aria-label="Anchor link for: systemadj 900" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<p>SYSTEM_ADJ: 仅指system_server进程。在执行SystemServer的startBootstrapServices()过程会调用AMS.setSystemProcess()，将system_server进程的maxAdj设置成SYSTEM_ADJ，源码如下：</p>

<h4 id="setsystemprocess">场景1：setSystemProcess<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#setsystemprocess" aria-label="Anchor link for: setsystemprocess" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<div class="highlighter-rouge"><pre class="highlight"><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSystemProcess</span><span class="hljs-params">()</span> </span>{
    ...
    ApplicationInfo info = mContext.getPackageManager().getApplicationInfo(
            <span class="hljs-string">"android"</span>, STOCK_PM_FLAGS | MATCH_SYSTEM_ONLY);
    mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
        ProcessRecord app = newProcessRecordLocked(info, info.processName, <span class="hljs-keyword">false</span>, <span class="hljs-number">0</span>);
        app.persistent = <span class="hljs-keyword">true</span>;
        app.pid = MY_PID;
        app.maxAdj = ProcessList.SYSTEM_ADJ;
        app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);
        <span class="hljs-keyword">synchronized</span> (mPidsSelfLocked) {
            mPidsSelfLocked.put(app.pid, app);
        }
        updateLruProcessLocked(app, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
        updateOomAdjLocked();
    }
    ...
}
</code></pre>
</div>

<p>但system_server的ADJ并非等于-900，而是-800？是由于startPersistentApps()过程直接把其adj重新被设置为-800，这算是一个小BUG，但
其实目前来说对于ADJ&lt;0的进程，LMK不会杀，两者没有什么区别。</p>

<h3 id="persistentprocadj-800">2.3 PERSISTENT_PROC_ADJ(-800)<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#persistentprocadj-800" aria-label="Anchor link for: persistentprocadj 800" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<p>PERSISTENT_PROC_ADJ：在AndroidManifest.xml中申明android:persistent=”true”的系统(即带有FLAG_SYSTEM标记)进程，称之为persistent进程。对于persistent进程常规情况都不会被杀，一旦被杀或者发生Crash，进程会立即重启。</p>

<p>AMS.addAppLocked(）或AMS.newProcessRecordLocked()过程会赋值：</p>

<h4 id="newprocessrecordlocked">场景1：newProcessRecordLocked<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#newprocessrecordlocked" aria-label="Anchor link for: newprocessrecordlocked" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<div class="highlighter-rouge"><pre class="highlight"><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> ProcessRecord <span class="hljs-title">newProcessRecordLocked</span><span class="hljs-params">(ApplicationInfo info, String customProcess,
      <span class="hljs-keyword">boolean</span> isolated, <span class="hljs-keyword">int</span> isolatedUid)</span> </span>{
  String proc = customProcess != <span class="hljs-keyword">null</span> ? customProcess : info.processName;
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> userId = UserHandle.getUserId(info.uid);
  <span class="hljs-keyword">int</span> uid = info.uid;
  ...
  <span class="hljs-keyword">final</span> ProcessRecord r = <span class="hljs-keyword">new</span> ProcessRecord(stats, info, proc, uid);
  <span class="hljs-keyword">if</span> (!mBooted &amp;&amp; !mBooting
          &amp;&amp; userId == UserHandle.USER_SYSTEM
          &amp;&amp; (info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) {
      r.persistent = <span class="hljs-keyword">true</span>;
      r.maxAdj = ProcessList.PERSISTENT_PROC_ADJ;
  }
  <span class="hljs-keyword">if</span> (isolated &amp;&amp; isolatedUid != <span class="hljs-number">0</span>) {
      r.maxAdj = ProcessList.PERSISTENT_SERVICE_ADJ;
  }
  <span class="hljs-keyword">return</span> r;
}
</code></pre>
</div>

<p>在每一次进程启动的时候都会判断该进程是否persistent进程，如果是则会设置maxAdj=PERSISTENT_PROC_ADJ。
system_server进程应该也是persistent进程？</p>

<h4 id="addapplocked">场景2：addAppLocked<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#addapplocked" aria-label="Anchor link for: addapplocked" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<div class="highlighter-rouge"><pre class="highlight"><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> ProcessRecord <span class="hljs-title">addAppLocked</span><span class="hljs-params">(ApplicationInfo info, String customProcess, <span class="hljs-keyword">boolean</span> isolated,
        String abiOverride)</span> </span>{
    ProcessRecord app;
    <span class="hljs-keyword">if</span> (!isolated) {
        app = getProcessRecordLocked(customProcess != <span class="hljs-keyword">null</span> ? customProcess : info.processName,
                info.uid, <span class="hljs-keyword">true</span>);
    } <span class="hljs-keyword">else</span> {
        app = <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-keyword">if</span> (app == <span class="hljs-keyword">null</span>) {
        app = newProcessRecordLocked(info, customProcess, isolated, <span class="hljs-number">0</span>);
        updateLruProcessLocked(app, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
        updateOomAdjLocked();
    }
    ...
    
    <span class="hljs-keyword">if</span> ((info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) {
        app.persistent = <span class="hljs-keyword">true</span>;
        app.maxAdj = ProcessList.PERSISTENT_PROC_ADJ;
    }
    <span class="hljs-keyword">if</span> (app.thread == <span class="hljs-keyword">null</span> &amp;&amp; mPersistentStartingProcesses.indexOf(app) &lt; <span class="hljs-number">0</span>) {
        mPersistentStartingProcesses.add(app);
        startProcessLocked(app, <span class="hljs-string">"added application"</span>,
                customProcess != <span class="hljs-keyword">null</span> ? customProcess : app.processName, abiOverride);
    }
    <span class="hljs-keyword">return</span> app;
}
</code></pre>
</div>

<p>开机过程会先启动persistent进程，并赋予maxAdj为PERSISTENT_PROC_ADJ，调用链：</p>

<div class="highlighter-rouge"><pre class="highlight"><code class="hljs css"><span class="hljs-selector-tag">startOtherServices</span>()
  <span class="hljs-selector-tag">AMS</span><span class="hljs-selector-class">.systemReady</span>
    <span class="hljs-selector-tag">AMS</span><span class="hljs-selector-class">.startPersistentApps</span>
      <span class="hljs-selector-tag">AMS</span><span class="hljs-selector-class">.addAppLocked</span>
</code></pre>
</div>

<h3 id="persistentserviceadj-700">2.4 PERSISTENT_SERVICE_ADJ(-700)<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#persistentserviceadj-700" aria-label="Anchor link for: persistentserviceadj 700" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<p>PERSISTENT_SERVICE_ADJ: startIsolatedProcess()方式启动的进程，或者是由system_server或者persistent进程所绑定的服务进程。</p>

<h4 id="newprocessrecordlocked-1">场景1：newProcessRecordLocked<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#newprocessrecordlocked-1" aria-label="Anchor link for: newprocessrecordlocked 1" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<p>AMS.newProcessRecordLocked()过程会赋值：</p>

<div class="highlighter-rouge"><pre class="highlight"><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> ProcessRecord <span class="hljs-title">newProcessRecordLocked</span><span class="hljs-params">(ApplicationInfo info, String customProcess,
      <span class="hljs-keyword">boolean</span> isolated, <span class="hljs-keyword">int</span> isolatedUid)</span> </span>{
  String proc = customProcess != <span class="hljs-keyword">null</span> ? customProcess : info.processName;
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> userId = UserHandle.getUserId(info.uid);
  <span class="hljs-keyword">int</span> uid = info.uid;
  ...
  <span class="hljs-keyword">final</span> ProcessRecord r = <span class="hljs-keyword">new</span> ProcessRecord(stats, info, proc, uid);
  <span class="hljs-keyword">if</span> (!mBooted &amp;&amp; !mBooting
          &amp;&amp; userId == UserHandle.USER_SYSTEM
          &amp;&amp; (info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) {
      r.persistent = <span class="hljs-keyword">true</span>;
      r.maxAdj = ProcessList.PERSISTENT_PROC_ADJ;
  }
  <span class="hljs-keyword">if</span> (isolated &amp;&amp; isolatedUid != <span class="hljs-number">0</span>) { <span class="hljs-comment">//startIsolatedProcess</span>
      r.maxAdj = ProcessList.PERSISTENT_SERVICE_ADJ;
  }
  <span class="hljs-keyword">return</span> r;
}
</code></pre>
</div>

<p>调用链：</p>

<div class="highlighter-rouge"><pre class="highlight"><code class="hljs css"><span class="hljs-selector-tag">startOtherServices</span>
  <span class="hljs-selector-tag">WebViewUpdateService</span><span class="hljs-selector-class">.prepareWebViewInSystemServer</span>
    <span class="hljs-selector-tag">WebViewUpdateServiceImpl</span><span class="hljs-selector-class">.prepareWebViewInSystemServer</span>
      <span class="hljs-selector-tag">WebViewUpdater</span><span class="hljs-selector-class">.prepareWebViewInSystemServer</span>
        <span class="hljs-selector-tag">WebViewUpdater</span><span class="hljs-selector-class">.onWebViewProviderChanged</span>
          <span class="hljs-selector-tag">SystemImpl</span><span class="hljs-selector-class">.onWebViewProviderChanged</span>
            <span class="hljs-selector-tag">WebViewFactory</span><span class="hljs-selector-class">.onWebViewProviderChanged</span>
              <span class="hljs-selector-tag">WebViewLibraryLoader</span><span class="hljs-selector-class">.prepareNativeLibraries</span>
                <span class="hljs-selector-tag">WebViewLibraryLoader</span><span class="hljs-selector-class">.createRelros</span>
                  <span class="hljs-selector-tag">WebViewLibraryLoader</span><span class="hljs-selector-class">.createRelroFile</span>
                    <span class="hljs-selector-tag">AMS</span><span class="hljs-selector-class">.startIsolatedProcess</span>
</code></pre>
</div>

<h4 id="computeoomadjlocked">场景2：computeOomAdjLocked<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#computeoomadjlocked" aria-label="Anchor link for: computeoomadjlocked" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>
<p>ServiceRecord的成员变量startRequested=true，是指被显式调用了startService()方法。当service被stop或kill会将其置为false。
AMS.computeOomAdjLocked()过程：(为了简化说明，调整部分源码)</p>

<pre><code class="language-Java hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> is = app.services.size()-<span class="hljs-number">1</span>; is &gt;= <span class="hljs-number">0</span>; is--) {
    ServiceRecord s = app.services.valueAt(is);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> conni = s.connections.size()-<span class="hljs-number">1</span>; conni &gt;= <span class="hljs-number">0</span>; conni--) {
        ArrayList&lt;ConnectionRecord&gt; clist = s.connections.valueAt(conni);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; clist.size(); i++) {
            ConnectionRecord cr = clist.get(i);
            
            <span class="hljs-keyword">if</span> (adj &gt; clientAdj) {
                <span class="hljs-keyword">if</span> (app.hasShownUi &amp;&amp; app != mHomeProcess
                        &amp;&amp; clientAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) {
                    ...
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> ((cr.flags&amp;(Context.BIND_ABOVE_CLIENT
                            |Context.BIND_IMPORTANT)) != <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">int</span> newAdj = clientAdj &gt;= ProcessList.PERSISTENT_SERVICE_ADJ
                                ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
                    }
                }
            }
        }
    }
}
</code></pre>

<p>当客户端进程优先级小于或等于PERSISTENT_SERVICE_ADJ，则设置该进程为PERSISTENT_SERVICE_ADJ。</p>

<h4 id="service-flags">Service flags解释<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#service-flags" aria-label="Anchor link for: service flags" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<p>一般情况下，即便客户端进程处于前台进程(ADJ=0)级别，服务进程只会提升到可见(ADJ=1)级别。以下flags是由调用bindService()过程所传递的flags来决定的。</p>

<ul>
  <li>BIND_ABOVE_CLIENT：当客户端进程绑定到一个服务进程时，则服务进程比客户端进程更重要。</li>
  <li>BIND_IMPORTANT： 标记该服务对于客户端进程很重要，当客户端进程处于前台进程(ADJ=0)级别时，会把服务进程也提升到前台进程级别。</li>
  <li>BIND_NOT_VISIBLE: 当客户端进程处于可见(ADJ=1)级别，也不允许被绑定的服务进程提升到可见级别，该类服务进程的优先级上限为可感知(ADJ=2)级别。</li>
  <li>BIND_NOT_FOREGROUND：不允许被绑定的服务进程提升到前台调度优先级，但是内存优先级可以提升到前台级别。</li>
</ul>

<p>作为工程师很多时候可能还是想看看源码，show me the code。但是关于ADJ计算这一块源码，Google真心写得比较乱，为了更清晰地说明客户端进程如何影响服务进程，在保证不失去原意的情况下重写了这块逻辑：</p>

<div class="highlighter-rouge"><pre class="highlight"><code class="hljs objectivec"><span class="hljs-keyword">int</span> newAdj = clientAdj;
<span class="hljs-keyword">if</span> ((cr.flags&amp;(Context.BIND_ABOVE_CLIENT
        |Context.BIND_IMPORTANT)) != <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(clientAdj &lt; ProcessList.PERSISTENT_SERVICE_ADJ) {
        newAdj = PERSISTENT_SERVICE_ADJ;
    }
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((cr.flags&amp;Context.BIND_NOT_VISIBLE) != <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(clientAdj &lt; ProcessList.PERCEPTIBLE_APP_ADJ) {
        newAdj = PERCEPTIBLE_APP_ADJ;
    }
} <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (clientAdj &lt; ProcessList.VISIBLE_APP_ADJ) {
        newAdj = VISIBLE_APP_ADJ;
    }
}

<span class="hljs-keyword">if</span> (adj &gt; newAdj) {
    adj = newAdj;
    adjType = <span class="hljs-string">"service"</span>;
}
</code></pre>
</div>

<p>上段代码说明服务端进程优先级(adj)不会低于客户端进程优先级(newAdj)，而newAdj的上限受限于flags，具体影响如下：</p>

<div class="table-responsive"><table class="table">
  <thead>
    <tr>
      <th>flags</th>
      <th>ADJ上限</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>BIND_ABOVE_CLIENT</td>
      <td>PERSISTENT_SERVICE_ADJ</td>
    </tr>
    <tr>
      <td>BIND_IMPORTANT</td>
      <td>PERSISTENT_SERVICE_ADJ</td>
    </tr>
    <tr>
      <td>BIND_NOT_VISIBLE</td>
      <td>PERCEPTIBLE_APP_ADJ</td>
    </tr>
    <tr>
      <td>-</td>
      <td>VISIBLE_APP_ADJ</td>
    </tr>
  </tbody>
</table></div>

<h3 id="foregroundappadj0">2.5 FOREGROUND_APP_ADJ(0)<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#foregroundappadj0" aria-label="Anchor link for: foregroundappadj0" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<h4 id="computeoomadjlocked-1">场景1：computeOomAdjLocked<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#computeoomadjlocked-1" aria-label="Anchor link for: computeoomadjlocked 1" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<div class="highlighter-rouge"><pre class="highlight"><code class="hljs bash"><span class="hljs-keyword">if</span> (PROCESS_STATE_CUR_TOP == ActivityManager.PROCESS_STATE_TOP &amp;&amp; app == TOP_APP) {
    adj = ProcessList.FOREGROUND_APP_ADJ;
    <span class="hljs-built_in">sched</span>Group = ProcessList.SCHED_GROUP_TOP_APP;
    app.adjType = <span class="hljs-string">"top-activity"</span>;
    foregroundActivities = <span class="hljs-literal">true</span>;
    procState = PROCESS_STATE_CUR_TOP;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (app.instr != null) {
    adj = ProcessList.FOREGROUND_APP_ADJ;
    <span class="hljs-built_in">sched</span>Group = ProcessList.SCHED_GROUP_DEFAULT;
    app.adjType = <span class="hljs-string">"instrumentation"</span>;
    procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isReceivingBroadcastLocked(app, mTmpBroadcastQueue)) {
    adj = ProcessList.FOREGROUND_APP_ADJ;
    <span class="hljs-built_in">sched</span>Group = (mTmpBroadcastQueue.contains(mFgBroadcastQueue))
            ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
    app.adjType = <span class="hljs-string">"broadcast"</span>;
    procState = ActivityManager.PROCESS_STATE_RECEIVER;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (app.executingServices.size() &gt; 0) {
    adj = ProcessList.FOREGROUND_APP_ADJ;
    <span class="hljs-built_in">sched</span>Group = app.execServicesFg ?
            ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
    app.adjType = <span class="hljs-string">"exec-service"</span>;
    procState = ActivityManager.PROCESS_STATE_SERVICE;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (app == TOP_APP) {
    adj = ProcessList.FOREGROUND_APP_ADJ;
    <span class="hljs-built_in">sched</span>Group = ProcessList.SCHED_GROUP_BACKGROUND;
    app.adjType = <span class="hljs-string">"top-sleeping"</span>;
    foregroundActivities = <span class="hljs-literal">true</span>;
    procState = PROCESS_STATE_CUR_TOP;
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">sched</span>Group = ProcessList.SCHED_GROUP_BACKGROUND;
    adj = cachedAdj;
    procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached = <span class="hljs-literal">true</span>;
    app.empty = <span class="hljs-literal">true</span>;
    app.adjType = <span class="hljs-string">"cch-empty"</span>;
}
</code></pre>
</div>

<p>包含以下任一条件的进程都属于FOREGROUND_APP_ADJ(0)优先级，场景如下：</p>

<div class="table-responsive"><table class="table">
  <thead>
    <tr>
      <th>场景</th>
      <th>对应procState</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>正处于resumed状态的activity</td>
      <td>PROCESS_STATE_TOP(2)</td>
    </tr>
    <tr>
      <td>正在执行生命周期回调的service</td>
      <td>PROCESS_STATE_SERVICE(10)</td>
    </tr>
    <tr>
      <td>正在执行onReceive()的广播接收者</td>
      <td>PROCESS_STATE_RECEIVER(11)</td>
    </tr>
    <tr>
      <td>通过startInstrumentation()启动的进程</td>
      <td>PROCESS_STATE_FOREGROUND_SERVICE(4)</td>
    </tr>
  </tbody>
</table></div>

<p>onCreate, onStartCommand/onDestroy, onBind, onRebind/onUnbind</p>

<ul>
  <li>正处于resumed状态的Activity</li>
  <li>正执行一个生命周期回调的Service（比如执行onCreate()、onStart()、onDestroy()等）</li>
  <li>正执行onReceive()的BroadcastReceiver</li>
</ul>

<h4 id="bindservice">场景2：bindService<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#bindservice" aria-label="Anchor link for: bindservice" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<pre><code class="language-Java hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> is = app.services.size()-<span class="hljs-number">1</span>; is &gt;= <span class="hljs-number">0</span>; is--) {
    ServiceRecord s = app.services.valueAt(is);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> conni = s.connections.size()-<span class="hljs-number">1</span>; conni &gt;= <span class="hljs-number">0</span>; conni--) {
        ArrayList&lt;ConnectionRecord&gt; clist = s.connections.valueAt(conni);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; clist.size(); i++) {
            ConnectionRecord cr = clist.get(i);
            ...
            <span class="hljs-keyword">final</span> ActivityRecord a = cr.activity;
            <span class="hljs-keyword">if</span> ((cr.flags&amp;Context.BIND_ADJUST_WITH_ACTIVITY) != <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span> &amp;&amp; adj &gt; ProcessList.FOREGROUND_APP_ADJ &amp;&amp;
                    (a.visible || a.state == ActivityState.RESUMED ||
                     a.state == ActivityState.PAUSING)) {
                    adj = ProcessList.FOREGROUND_APP_ADJ;
                    <span class="hljs-keyword">if</span> ((cr.flags&amp;Context.BIND_NOT_FOREGROUND) == <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">if</span> ((cr.flags&amp;Context.BIND_IMPORTANT) != <span class="hljs-number">0</span>) {
                            schedGroup = ProcessList.SCHED_GROUP_TOP_APP_BOUND;
                        } <span class="hljs-keyword">else</span> {
                            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                        }
                    }
                    app.cached = <span class="hljs-keyword">false</span>;
                    app.adjType = <span class="hljs-string">"service"</span>;
                    app.adjTypeCode = ActivityManager.RunningAppProcessInfo
                            .REASON_SERVICE_IN_USE;
                    app.adjSource = a;
                    app.adjSourceProcState = procState;
                    app.adjTarget = s.name;
                }
            }
        }
    }
}
</code></pre>

<p>BIND_ADJUST_WITH_ACTIVITY</p>

<h4 id="provider">场景3：provider<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#provider" aria-label="Anchor link for: provider" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<pre><code class="language-Java hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> provi = app.pubProviders.size()-<span class="hljs-number">1</span>; provi &gt;= <span class="hljs-number">0</span>; provi--) {
    ContentProviderRecord cpr = app.pubProviders.valueAt(provi);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = cpr.connections.size()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
        ContentProviderConnection conn = cpr.connections.get(i);
        ProcessRecord client = conn.client;
        <span class="hljs-keyword">int</span> clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);
        ...
        <span class="hljs-keyword">if</span> (adj &gt; clientAdj) {
            <span class="hljs-keyword">if</span> (app.hasShownUi &amp;&amp; app != mHomeProcess
                    &amp;&amp; clientAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) {
                ...
            } <span class="hljs-keyword">else</span> {
                adj = clientAdj &gt; ProcessList.FOREGROUND_APP_ADJ
                        ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
                adjType = <span class="hljs-string">"provider"</span>;
            }
            app.cached &amp;= client.cached;
        }
        ...
    }

    <span class="hljs-keyword">if</span> (cpr.hasExternalProcessHandles()) {
         <span class="hljs-keyword">if</span> (adj &gt; ProcessList.FOREGROUND_APP_ADJ) {
             adj = ProcessList.FOREGROUND_APP_ADJ;
             schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
             app.cached = <span class="hljs-keyword">false</span>;
             app.adjType = <span class="hljs-string">"ext-provider"</span>;
             app.adjTarget = cpr.name;
         }
     }
}
</code></pre>

<ul>
  <li>当Provider的客户端进程ADJ&lt;=FOREGROUND_APP_ADJ时，则Provider进程ADJ等于FOREGROUND_APP_ADJ</li>
  <li>当Provider有外部(非框架)进程依赖，则ADJ至少等于FOREGROUND_APP_ADJ</li>
</ul>

<p>说明：当同一个进程有多个决定其优先级的组件状态时，取优先级最高的ADJ作为最终的ADJ</p>

<h3 id="visibleappadj100">2.6 VISIBLE_APP_ADJ(100)<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#visibleappadj100" aria-label="Anchor link for: visibleappadj100" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>
<p>VISIBLE_APP_LAYER_MAX = 99，是指VISIBLE_APP_ADJ(100)跟PERCEPTIBLE_APP_ADJ(200)之间有99个槽，</p>

<h4 id="section-3">场景1<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#section-3" aria-label="Anchor link for: section 3" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<pre><code class="language-Java hljs"><span class="hljs-keyword">if</span> (!foregroundActivities &amp;&amp; activitiesSize &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">int</span> minLayer = ProcessList.VISIBLE_APP_LAYER_MAX;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; activitiesSize; j++) {
        <span class="hljs-keyword">final</span> ActivityRecord r = app.activities.get(j);
        <span class="hljs-keyword">if</span> (r.visible) {
            <span class="hljs-keyword">if</span> (adj &gt; ProcessList.VISIBLE_APP_ADJ) {
                adj = ProcessList.VISIBLE_APP_ADJ;
                app.adjType = <span class="hljs-string">"vis-activity"</span>;
            }
            <span class="hljs-keyword">if</span> (procState &gt; PROCESS_STATE_CUR_TOP) {
                procState = PROCESS_STATE_CUR_TOP;
                app.adjType = <span class="hljs-string">"vis-activity"</span>;
            }
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
            app.cached = <span class="hljs-keyword">false</span>;
            app.empty = <span class="hljs-keyword">false</span>;
            foregroundActivities = <span class="hljs-keyword">true</span>;
            <span class="hljs-keyword">final</span> TaskRecord task = r.getTask();
            <span class="hljs-keyword">if</span> (task != <span class="hljs-keyword">null</span> &amp;&amp; minLayer &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> layer = task.mLayerRank;
                <span class="hljs-keyword">if</span> (layer &gt;= <span class="hljs-number">0</span> &amp;&amp; minLayer &gt; layer) {
                    minLayer = layer;
                }
            }
            <span class="hljs-keyword">break</span>;
        }
        ...
    }
    <span class="hljs-keyword">if</span> (adj == ProcessList.VISIBLE_APP_ADJ) {
        adj += minLayer;
    }
}
</code></pre>

<p>当ActivityRecord的visible=true，也就是Activity可见的进程属于VISIBLE_APP_ADJ级别的进程。</p>

<p>从Android P开始，进一步细化ADJ级别，增加了VISIBLE_APP_LAYER_MAX，可见级别ADJ的取值范围为[100,199]。
算法会根据其所在task的mLayerRank来调整其ADJ，100加上mLayerRank就等于目标ADJ，layer越大，则ADJ越小。</p>

<p>关于TaskRecord的mLayerRank的计算方式：</p>

<pre><code class="language-Java hljs">[-&gt; ActivityStackSupervisor.java]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rankTaskLayersIfNeeded</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (!mTaskLayersChanged) {
        <span class="hljs-keyword">return</span>;
    }
    mTaskLayersChanged = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> displayNdx = <span class="hljs-number">0</span>; displayNdx &lt; mActivityDisplays.size(); displayNdx++) {
        <span class="hljs-keyword">final</span> ActivityDisplay display = mActivityDisplays.valueAt(displayNdx);
        <span class="hljs-keyword">int</span> baseLayer = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> stackNdx = display.getChildCount() - <span class="hljs-number">1</span>; stackNdx &gt;= <span class="hljs-number">0</span>; --stackNdx) {
            <span class="hljs-keyword">final</span> ActivityStack stack = display.getChildAt(stackNdx);
            baseLayer += stack.rankTaskLayers(baseLayer);
        }
    }
}
</code></pre>

<pre><code class="language-Java hljs">[-&gt; ActivityStack.java]
<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rankTaskLayers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> baseLayer)</span> </span>{
    <span class="hljs-keyword">int</span> layer = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> taskNdx = mTaskHistory.size() - <span class="hljs-number">1</span>; taskNdx &gt;= <span class="hljs-number">0</span>; --taskNdx) {
        <span class="hljs-keyword">final</span> TaskRecord task = mTaskHistory.get(taskNdx);
        ActivityRecord r = task.topRunningActivityLocked();
        <span class="hljs-keyword">if</span> (r == <span class="hljs-keyword">null</span> || r.finishing || !r.visible) {
            task.mLayerRank = -<span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            task.mLayerRank = baseLayer + layer++;
        }
    }
    <span class="hljs-keyword">return</span> layer;
}
</code></pre>

<p>当TaskRecord顶部的ActivityRecord为空或者结束或者不可见时，则设置该TaskRecord的mLayerRank等于-1; 每个ActivityDisplay的baseLayer都是从0开始，从最上面的TaskRecord开始，第一个ADJ=100，从上至下依次加1，直到199为上限。</p>

<p><img src="./解读Android进程优先级ADJ算法 - Gityuan博客 _ 袁辉辉博客_files/visible_adj_layer.png" alt="visible_adj_layer"></p>

<p>调用链：</p>

<div class="highlighter-rouge"><pre class="highlight"><code class="hljs css"><span class="hljs-selector-tag">AMS</span><span class="hljs-selector-class">.updateOomAdjLocked</span>
  <span class="hljs-selector-tag">ASS</span><span class="hljs-selector-class">.rankTaskLayersIfNeeded</span>
    <span class="hljs-selector-tag">AS</span><span class="hljs-selector-class">.rankTaskLayers</span>
</code></pre>
</div>

<h4 id="section-4">场景2<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#section-4" aria-label="Anchor link for: section 4" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<p>（雷同于#2.4的第4个）</p>

<h3 id="perceptibleappadj200">2.7 PERCEPTIBLE_APP_ADJ(200)<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#perceptibleappadj200" aria-label="Anchor link for: perceptibleappadj200" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<h4 id="activity">场景1：Activity状态<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#activity" aria-label="Anchor link for: activity" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<p>存在不可见的Activity，但Activity正处于PAUSING、PAUSED、STOPPING状态，则为PERCEPTIBLE_APP_ADJ</p>

<pre><code class="language-Java hljs"><span class="hljs-keyword">if</span> (!foregroundActivities &amp;&amp; activitiesSize &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">int</span> minLayer = ProcessList.VISIBLE_APP_LAYER_MAX;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; activitiesSize; j++) {
        <span class="hljs-keyword">final</span> ActivityRecord r = app.activities.get(j);
        <span class="hljs-keyword">if</span> (r.visible) {
            ...
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
            <span class="hljs-keyword">if</span> (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                app.adjType = <span class="hljs-string">"pause-activity"</span>;
            }
            <span class="hljs-keyword">if</span> (procState &gt; PROCESS_STATE_CUR_TOP) {
                procState = PROCESS_STATE_CUR_TOP;
                app.adjType = <span class="hljs-string">"pause-activity"</span>;
            }
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
            app.cached = <span class="hljs-keyword">false</span>;
            app.empty = <span class="hljs-keyword">false</span>;
            foregroundActivities = <span class="hljs-keyword">true</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r.state == ActivityState.STOPPING) {
            <span class="hljs-keyword">if</span> (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                app.adjType = <span class="hljs-string">"stop-activity"</span>;
            }
            
            <span class="hljs-keyword">if</span> (!r.finishing) {
                <span class="hljs-keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
                    procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
                    app.adjType = <span class="hljs-string">"stop-activity"</span>;
                }
            }
            app.cached = <span class="hljs-keyword">false</span>;
            app.empty = <span class="hljs-keyword">false</span>;
            foregroundActivities = <span class="hljs-keyword">true</span>;
        }
    }
}
</code></pre>

<h4 id="fg-service">场景2： fg-service<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#fg-service" aria-label="Anchor link for: fg service" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<pre><code class="language-Java hljs"><span class="hljs-keyword">if</span> (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ
        || procState &gt; ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) {
    <span class="hljs-keyword">if</span> (app.foregroundServices) {
        <span class="hljs-comment">// The user is aware of this app, so make it visible.</span>
        adj = ProcessList.PERCEPTIBLE_APP_ADJ;
        procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
        app.cached = <span class="hljs-keyword">false</span>;
        app.adjType = <span class="hljs-string">"fg-service"</span>;
        schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (app.hasOverlayUi) {
        adj = ProcessList.PERCEPTIBLE_APP_ADJ;
        procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
        app.cached = <span class="hljs-keyword">false</span>;
        app.adjType = <span class="hljs-string">"has-overlay-ui"</span>;
        schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
    }
}

<span class="hljs-keyword">if</span> (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ
        || procState &gt; ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND) {
    <span class="hljs-keyword">if</span> (app.forcingToImportant != <span class="hljs-keyword">null</span>) {
        adj = ProcessList.PERCEPTIBLE_APP_ADJ;
        procState = ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND;
        app.cached = <span class="hljs-keyword">false</span>;
        app.adjType = <span class="hljs-string">"force-imp"</span>;
        app.adjSource = app.forcingToImportant;
        schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
    }
}
</code></pre>

<ul>
  <li>app.foregroundServices</li>
  <li>app.hasOverlayUi</li>
  <li>app.forcingToImportant != null</li>
</ul>

<h3 id="backupappadj300">8. BACKUP_APP_ADJ(300)<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#backupappadj300" aria-label="Anchor link for: backupappadj300" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<div class="highlighter-rouge"><pre class="highlight"><code class="hljs php"><span class="hljs-keyword">if</span> (mBackupTarget != <span class="hljs-keyword">null</span> &amp;&amp; app == mBackupTarget.app) {
    <span class="hljs-keyword">if</span> (adj &gt; ProcessList.BACKUP_APP_ADJ) {
        adj = ProcessList.BACKUP_APP_ADJ;
        <span class="hljs-keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND) {
            procState = ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND;
        }
        app.adjType = <span class="hljs-string">"backup"</span>;
        app.cached = <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_BACKUP) {
        procState = ActivityManager.PROCESS_STATE_BACKUP;
        app.adjType = <span class="hljs-string">"backup"</span>;
    }
}
</code></pre>
</div>

<ul>
  <li>执行bindBackupAgent()过程，设置mBackupTarget值；</li>
  <li>执行clearPendingBackup()或unbindBackupAgent()过程，置空mBackupTarget值；</li>
</ul>

<h3 id="heavyweightappadj400">9. HEAVY_WEIGHT_APP_ADJ(400)<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#heavyweightappadj400" aria-label="Anchor link for: heavyweightappadj400" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<ul>
  <li>realStartActivityLocked()过程，当应用的privateFlags标识PRIVATE_FLAG_CANT_SAVE_STATE，设置mHeavyWeightProcess值；</li>
  <li>finishHeavyWeightApp(), 置空mHeavyWeightProcess值；</li>
</ul>

<h3 id="serviceadj500">10. SERVICE_ADJ(500)<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#serviceadj500" aria-label="Anchor link for: serviceadj500" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<pre><code class="language-Java hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> is = app.services.size()-<span class="hljs-number">1</span>; is &gt;= <span class="hljs-number">0</span>; is--) {
    ServiceRecord s = app.services.valueAt(is);
    <span class="hljs-keyword">if</span> (s.startRequested) {
        app.hasStartedServices = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_SERVICE) {
            procState = ActivityManager.PROCESS_STATE_SERVICE;
            app.adjType = <span class="hljs-string">"started-services"</span>;
        }
        <span class="hljs-keyword">if</span> (app.hasShownUi &amp;&amp; app != mHomeProcess) {
            ...
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (now &lt; (s.lastActivity + mConstants.MAX_SERVICE_INACTIVITY)) {
                <span class="hljs-keyword">if</span> (adj &gt; ProcessList.SERVICE_ADJ) {
                    adj = ProcessList.SERVICE_ADJ;
                    app.adjType = <span class="hljs-string">"started-services"</span>;
                    app.cached = <span class="hljs-keyword">false</span>;
                }
            }
        }
    }
</code></pre>

<p>既没有显示过UI，活动时间也没有超过30分钟</p>

<h3 id="homeappadj600">11. HOME_APP_ADJ(600)<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#homeappadj600" aria-label="Anchor link for: homeappadj600" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<p>当类型为ACTIVITY_TYPE_HOME的应用启动后，会设置mHomeProcess，这便是平时的桌面APP</p>

<h3 id="previousappadj700">12. PREVIOUS_APP_ADJ(700)<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#previousappadj700" aria-label="Anchor link for: previousappadj700" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<p>ActivityRecord.activityStoppedLocked()过程，会执行ASS.updatePreviousProcessLocked()方法，</p>

<p>mPreviousProcess的赋值过程，如下：
当进程停止时，检测该进程是否需要设置为上一个应用。首先找到当前的前台APP, 判断是否属于同一个应用。</p>

<div class="highlighter-rouge"><pre class="highlight"><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updatePreviousProcessLocked</span><span class="hljs-params">(ActivityRecord r)</span> </span>{
    ProcessRecord fgApp = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> displayNdx = mActivityDisplays.size() - <span class="hljs-number">1</span>; displayNdx &gt;= <span class="hljs-number">0</span>; --displayNdx) {
        <span class="hljs-keyword">final</span> ActivityDisplay display = mActivityDisplays.valueAt(displayNdx);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> stackNdx = display.getChildCount() - <span class="hljs-number">1</span>; stackNdx &gt;= <span class="hljs-number">0</span>; --stackNdx) {
            <span class="hljs-keyword">final</span> ActivityStack stack = display.getChildAt(stackNdx);
            <span class="hljs-keyword">if</span> (isFocusedStack(stack)) {
                <span class="hljs-keyword">if</span> (stack.mResumedActivity != <span class="hljs-keyword">null</span>) {
                    fgApp = stack.mResumedActivity.app;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.mPausingActivity != <span class="hljs-keyword">null</span>) {
                    fgApp = stack.mPausingActivity.app;
                }
                <span class="hljs-keyword">break</span>;
            }
        }
    }

    <span class="hljs-keyword">if</span> (r.app != <span class="hljs-keyword">null</span> &amp;&amp; fgApp != <span class="hljs-keyword">null</span> &amp;&amp; r.app != fgApp
            &amp;&amp; r.lastVisibleTime &gt; mService.mPreviousProcessVisibleTime
            &amp;&amp; r.app != mService.mHomeProcess) {
        mService.mPreviousProcess = r.app;
        mService.mPreviousProcessVisibleTime = r.lastVisibleTime;
    }
}
</code></pre>
</div>

<h3 id="servicebadj800">13. SERVICE_B_ADJ(800)<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#servicebadj800" aria-label="Anchor link for: servicebadj800" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<div class="highlighter-rouge"><pre class="highlight"><code class="hljs objectivec"><span class="hljs-keyword">if</span> (adj == ProcessList.SERVICE_ADJ) {
    <span class="hljs-keyword">if</span> (doingAll) {
        app.serviceb = mNewNumAServiceProcs &gt; (mNumServiceProcs/<span class="hljs-number">3</span>);
        mNewNumServiceProcs++;
        <span class="hljs-keyword">if</span> (!app.serviceb) {
            <span class="hljs-keyword">if</span> (mLastMemoryLevel &gt; ProcessStats.ADJ_MEM_FACTOR_NORMAL
                    &amp;&amp; app.lastPss &gt;= mProcessList.getCachedRestoreThresholdKb()) {
                app.serviceHighRam = <span class="hljs-literal">true</span>;
                app.serviceb = <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> {
                mNewNumAServiceProcs++;
            }
        } <span class="hljs-keyword">else</span> {
            app.serviceHighRam = <span class="hljs-literal">false</span>;
        }
    }
    <span class="hljs-keyword">if</span> (app.serviceb) {
        adj = ProcessList.SERVICE_B_ADJ;
    }
}
</code></pre>
</div>

<p>进程由SERVICE_ADJ(500)降低到SERVICE_B_ADJ(800)的情况有以下两种：</p>

<ul>
  <li>当A类Service个数 &gt; Service总数的1/3时，则加入到B类Service</li>
  <li>当系统内存紧张级别(mLastMemoryLevel)高于ADJ_MEM_FACTOR_NORMAL，且该应用所占内存lastPss大于或等于CACHED_APP_MAX_ADJ级别所对应的内存阈值的1/3, 默认值为184320/3KB。</li>
</ul>

<h4 id="adjmemfactor">ADJ_MEM_FACTOR<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#adjmemfactor" aria-label="Anchor link for: adjmemfactor" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<p>这里顺便一下，内存因子ADJ_MEM_FACTOR共有4个级别。</p>

<pre><code class="language-Java hljs"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> numCachedAndEmpty = numCached + numEmpty;
<span class="hljs-keyword">int</span> memFactor;
<span class="hljs-keyword">if</span> (numCached &lt;= mConstants.CUR_TRIM_CACHED_PROCESSES
        &amp;&amp; numEmpty &lt;= mConstants.CUR_TRIM_EMPTY_PROCESSES) {
    <span class="hljs-keyword">if</span> (numCachedAndEmpty &lt;= ProcessList.TRIM_CRITICAL_THRESHOLD) {
        memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numCachedAndEmpty &lt;= ProcessList.TRIM_LOW_THRESHOLD) {
        memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW;
    } <span class="hljs-keyword">else</span> {
        memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;
    }
} <span class="hljs-keyword">else</span> {
    memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL;
}
</code></pre>

<p>private void updateMaxCachedProcesses() {
     //调用AMS.setProcessLimit()会设置mOverrideMaxCachedProcesses值
     CUR_MAX_CACHED_PROCESSES = mOverrideMaxCachedProcesses &lt; 0
             ? MAX_CACHED_PROCESSES : mOverrideMaxCachedProcesses;
     // CUR_MAX_EMPTY_PROCESSES等于CUR_MAX_CACHED_PROCESSES的1/2
     CUR_MAX_EMPTY_PROCESSES = computeEmptyProcessLimit(CUR_MAX_CACHED_PROCESSES);</p>

<div class="highlighter-rouge"><pre class="highlight"><code class="hljs objectivec"> final <span class="hljs-keyword">int</span> rawMaxEmptyProcesses = computeEmptyProcessLimit(MAX_<span class="hljs-built_in">CACHED_PROCESSES</span>);
 CUR_TRIM_E<span class="hljs-built_in">MPTY_PROCESSES</span> = rawMaxEmptyProcesses/<span class="hljs-number">2</span>;
 CUR_TRIM_<span class="hljs-built_in">CACHED_PROCESSES</span> = (MAX_<span class="hljs-built_in">CACHED_PROCESSES</span>-rawMaxEmptyProcesses)/<span class="hljs-number">3</span>;  }
</code></pre>
</div>

<p>默认情况下的取值如下：</p>

<ul>
  <li>CUR_MAX_CACHED_PROCESSES  = 32</li>
  <li>CUR_MAX_EMPTY_PROCESSES   = 32/2 = 16</li>
  <li>CUR_TRIM_EMPTY_PROCESSES  = 32/4 = 8</li>
  <li>CUR_TRIM_CACHED_PROCESSES = 32/6 = 5</li>
</ul>

<p>ADJ内存因子：决定允许后台运行Jobs的最大上限，以及决定TrimMemory的级别(包括ThreadedRenderer的回收级别)，再进一步来看看内存因子：</p>

<div class="table-responsive"><table class="table">
  <thead>
    <tr>
      <th>内存因子</th>
      <th>取值</th>
      <th>含义</th>
      <th>&nbsp;</th>
      <th>&nbsp;</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ADJ_MEM_FACTOR_CRITICAL</td>
      <td>3</td>
      <td>numCachedAndEmpty&lt;=3(固定)</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>ADJ_MEM_FACTOR_LOW</td>
      <td>2</td>
      <td>numCachedAndEmpty&lt;=5(固定)</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>ADJ_MEM_FACTOR_MODERATE</td>
      <td>1</td>
      <td>numCached&lt;=5 &amp;&amp; numEmpty&lt;=8</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>ADJ_MEM_FACTOR_NORMAL</td>
      <td>0</td>
      <td>numCached&gt;5</td>
      <td>&nbsp;</td>
      <td>numEmpty&gt;8</td>
    </tr>
  </tbody>
</table></div>

<p>再来看看cached和empty进程：</p>

<p>final int emptyProcessLimit = mConstants.CUR_MAX_EMPTY_PROCESSES;
        final int cachedProcessLimit = mConstants.CUR_MAX_CACHED_PROCESSES - emptyProcessLimit;</p>

<pre><code class="language-Java hljs"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> emptyProcessLimit = mConstants.CUR_MAX_EMPTY_PROCESSES;
<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> cachedProcessLimit = mConstants.CUR_MAX_CACHED_PROCESSES - emptyProcessLimit;
<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> oldTime = now - ProcessList.MAX_EMPTY_TIME;

<span class="hljs-keyword">switch</span> (app.curProcState) {
    <span class="hljs-keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
    <span class="hljs-keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
        mNumCachedHiddenProcs++;
        numCached++;
        <span class="hljs-comment">//默认cachedProcessLimit=16</span>
        <span class="hljs-keyword">if</span> (numCached &gt; cachedProcessLimit) {
            app.kill(<span class="hljs-string">"cached #"</span> + numCached, <span class="hljs-keyword">true</span>);
        }
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_EMPTY:
        <span class="hljs-comment">//默认CUR_TRIM_EMPTY_PROCESSES=8, 且满足30min</span>
        <span class="hljs-keyword">if</span> (numEmpty &gt; mConstants.CUR_TRIM_EMPTY_PROCESSES
                &amp;&amp; app.lastActivityTime &lt; oldTime) {
            app.kill(<span class="hljs-string">"empty for "</span>
                    + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)
                    / <span class="hljs-number">1000</span>) + <span class="hljs-string">"s"</span>, <span class="hljs-keyword">true</span>);
        } <span class="hljs-keyword">else</span> {
            numEmpty++;
            <span class="hljs-comment">//默认cachedProcessLimit=16</span>
            <span class="hljs-keyword">if</span> (numEmpty &gt; emptyProcessLimit) {
                app.kill(<span class="hljs-string">"empty #"</span> + numEmpty, <span class="hljs-keyword">true</span>);
            }
        }
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
        mNumNonCachedProcs++;
        <span class="hljs-keyword">break</span>;
</code></pre>

<p>用于限制empty或cached进程的上限为16个，并且empty超过8个时会清理掉30分钟没有活跃的进程。
cached和empty主要是区别是否有Activity。</p>

<h3 id="cachedappminadj900">14. CACHED_APP_MIN_ADJ(900)<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#cachedappminadj900" aria-label="Anchor link for: cachedappminadj900" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<p>缓存进程优先级从CACHED_APP_MIN_ADJ(900)到 CACHED_APP_MAX_ADJ(906)。</p>

<p>ADJ的转换算法：</p>

<ul>
  <li>cached: 900, 901, 903, 905</li>
  <li>empty:  900, 902, 904, 906</li>
</ul>

<pre><code class="language-Java hljs"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = mLruProcesses.size();
<span class="hljs-comment">//numSlots等于3</span>
<span class="hljs-keyword">int</span> numSlots = (ProcessList.CACHED_APP_MAX_ADJ
        - ProcessList.CACHED_APP_MIN_ADJ + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
<span class="hljs-comment">//mNumNonCachedProcs是指empty和cached之外的进程， mNumCachedHiddenProcs代表的是cached进程个数</span>
<span class="hljs-keyword">int</span> numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;
<span class="hljs-keyword">if</span> (numEmptyProcs &gt; cachedProcessLimit) {
    numEmptyProcs = cachedProcessLimit;
}
<span class="hljs-keyword">int</span> emptyFactor = numEmptyProcs/numSlots;
<span class="hljs-keyword">if</span> (emptyFactor &lt; <span class="hljs-number">1</span>) emptyFactor = <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> cachedFactor = (mNumCachedHiddenProcs &gt; <span class="hljs-number">0</span> ? mNumCachedHiddenProcs : <span class="hljs-number">1</span>)/numSlots;
<span class="hljs-keyword">if</span> (cachedFactor &lt; <span class="hljs-number">1</span>) cachedFactor = <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> stepCached = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> stepEmpty = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> numCached = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> numEmpty = <span class="hljs-number">0</span>;

mNumNonCachedProcs = <span class="hljs-number">0</span>;
mNumCachedHiddenProcs = <span class="hljs-number">0</span>;

<span class="hljs-keyword">int</span> curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;
<span class="hljs-keyword">int</span> nextCachedAdj = curCachedAdj+<span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ;
<span class="hljs-keyword">int</span> nextEmptyAdj = curEmptyAdj+<span class="hljs-number">2</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=N-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--) {
    ProcessRecord app = mLruProcesses.get(i);
    <span class="hljs-keyword">if</span> (!app.killedByAm &amp;&amp; app.thread != <span class="hljs-keyword">null</span>) {
        app.procStateChanged = <span class="hljs-keyword">false</span>;
        computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, <span class="hljs-keyword">true</span>, now);

        <span class="hljs-keyword">if</span> (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ) {
            <span class="hljs-keyword">switch</span> (app.curProcState) {
                <span class="hljs-keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
                <span class="hljs-keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                <span class="hljs-keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_RECENT:
                    app.curRawAdj = curCachedAdj;
                    app.curAdj = app.modifyRawOomAdj(curCachedAdj);
                    <span class="hljs-keyword">if</span> (curCachedAdj != nextCachedAdj) {
                        stepCached++;
                        <span class="hljs-keyword">if</span> (stepCached &gt;= cachedFactor) {
                            stepCached = <span class="hljs-number">0</span>;
                            curCachedAdj = nextCachedAdj;
                            nextCachedAdj += <span class="hljs-number">2</span>; <span class="hljs-comment">//每次加2</span>
                            <span class="hljs-keyword">if</span> (nextCachedAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) {
                                nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;
                            }
                        }
                    }
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>:
                    app.curRawAdj = curEmptyAdj;
                    <span class="hljs-comment">//ADJ阈值</span>
                    app.curAdj = app.modifyRawOomAdj(curEmptyAdj);
                    <span class="hljs-keyword">if</span> (curEmptyAdj != nextEmptyAdj) {
                        stepEmpty++;
                        <span class="hljs-keyword">if</span> (stepEmpty &gt;= emptyFactor) {
                            stepEmpty = <span class="hljs-number">0</span>;
                            curEmptyAdj = nextEmptyAdj;
                            nextEmptyAdj += <span class="hljs-number">2</span>; <span class="hljs-comment">//每次加2</span>
                            <span class="hljs-keyword">if</span> (nextEmptyAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) {
                                nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;
                            }
                        }
                    }
                    <span class="hljs-keyword">break</span>;
            }
        }

        applyOomAdjLocked(app, <span class="hljs-keyword">true</span>, now, nowElapsed);
        ...
    }
}

</code></pre>

<p>再来看看PROCESS_STATE_CACHED_ACTIVITY的定义：</p>

<pre><code class="language-Java hljs"><span class="hljs-keyword">if</span> (!foregroundActivities &amp;&amp; activitiesSize &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; activitiesSize; j++) {
        <span class="hljs-keyword">final</span> ActivityRecord r = app.activities.get(j);
        <span class="hljs-keyword">if</span> (r.visible) {
            ...
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
            ...
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r.state == ActivityState.STOPPING) {
            ...
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
                app.adjType = <span class="hljs-string">"cch-act"</span>;
            }
        }
    }
}
</code></pre>

<p>foregroundActivities代表当前不是前台(FOREGROUND_APP_ADJ)进程，并且存在Activity的进程，当该Activity窗口不可见，并且不处于PAUSING(正在)、PAUSED(onPause个)、STOPPING的任一状态的情况下，则设置该进程为PROCESS_STATE_CACHED_ACTIVITY。</p>

<p>PROCESS_STATE_CACHED_ACTIVITY_CLIENT的定义：</p>

<pre><code class="language-Java hljs"><span class="hljs-keyword">if</span> (procState &gt;= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
    <span class="hljs-keyword">if</span> (app.hasClientActivities) {
        procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
        app.adjType = <span class="hljs-string">"cch-client-act"</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (app.treatLikeActivity) {
        procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
        app.adjType = <span class="hljs-string">"cch-as-act"</span>;
    }
}
</code></pre>

<p>当该进程Service的客户端进程存在Activity或者是treatLikeActivity的进程，其进程状态都是cached进程。</p>

<p>通过设置maxAdj来限定ADJ的上限。</p>

<h2 id="section-5">三、查看进程优先级<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#section-5" aria-label="Anchor link for: section 5" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h2>

<h3 id="cpu">3.1 CPU调度优先级<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#cpu" aria-label="Anchor link for: cpu" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<p>bindService或者startService是否前台调用取决于caller进程的调度组。当caller属于SCHED_GROUP_BACKGROUND则认为是后台调用，当不属于SCHED_GROUP_BACKGROUND则认为是前台调用。
callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;</p>

<p>关于CPU调度组：</p>

<div class="table-responsive"><table class="table">
  <thead>
    <tr>
      <th>调度级别</th>
      <th>进程组</th>
      <th>备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SCHED_GROUP_BACKGROUND</td>
      <td>THREAD_GROUP_BG_NONINTERACTIVE</td>
      <td>后台进程组</td>
    </tr>
    <tr>
      <td>SCHED_GROUP_DEFAULT</td>
      <td>THREAD_GROUP_DEFAULT</td>
      <td>前台进程组</td>
    </tr>
    <tr>
      <td>SCHED_GROUP_TOP_APP</td>
      <td>THREAD_GROUP_TOP_APP</td>
      <td>TOP进程组</td>
    </tr>
    <tr>
      <td>SCHED_GROUP_TOP_APP_BOUND</td>
      <td>THREAD_GROUP_TOP_APP</td>
      <td>TOP进程组</td>
    </tr>
  </tbody>
</table></div>

<h4 id="threadgrouptopapp">THREAD_GROUP_TOP_APP<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#threadgrouptopapp" aria-label="Anchor link for: threadgrouptopapp" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<ul>
  <li>SCHED_GROUP_TOP_APP：
    <ul>
      <li>setRenderThread()过程，根据属性sys.use_fifo_ui来决定采用SCHED_FIFO，或者设置当前线程的优先级为-10</li>
      <li>TOP_APP或者app.hasTopUi，则设置为该值</li>
    </ul>
  </li>
  <li>SCHED_GROUP_TOP_APP_BOUND：
    <ul>
      <li>对于ConnectionRecord带有BIND_ADJUST_WITH_ACTIVITY和BIND_IMPORTANT，并且没带有BIND_NOT_FOREGROUND的情况下，
当客户端进程的有可见的Activity，或者处于RESUMED/PAUSING状态时，则设置为该值</li>
    </ul>
  </li>
</ul>

<p>当进程调度级别由非TOP切换到TOP级别，则主线程和rendThread可设置为SCHED_FIFO或者更高优先级；当由TOP级别切换回非TOP级别，则恢复原来的调度策略或优先级。</p>

<h4 id="threadgroupdefault">THREAD_GROUP_DEFAULT<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#threadgroupdefault" aria-label="Anchor link for: threadgroupdefault" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<ul>
  <li>SCHED_GROUP_DEFAULT：
    <ul>
      <li>默认值</li>
      <li>ADJ &lt;= FOREGROUND_APP_ADJ；</li>
      <li>正在接收来自于mFgBroadcastQueue广播队列的广播；</li>
      <li>正在执行来自于前台调度进程发起的服务(execServicesFg=true)</li>
      <li>Activity处于可见状态(visible=true)</li>
      <li>具有fg-service或者设置forcingToImportant的服务</li>
      <li>正在显示一个overlay UI(app.hasOverlayUi=true)</li>
      <li>当ConnectionRecord同时没有指定BIND_NOT_FOREGROUND和BIND_IMPORTANT_BACKGROUND、BIND_IMPORTANT情况下，
当客户端进程的schedGroup高于服务进程，则设置为该值</li>
      <li>对于ConnectionRecord带有BIND_ADJUST_WITH_ACTIVITY，并且没带有BIND_NOT_FOREGROUND和BIND_IMPORTANT的情况下，
当客户端进程的有可见的Activity，或者处于RESUMED/PAUSING状态时，则设置为该值</li>
      <li>当ContentProviderConnection所对应的客户端进程的schedGroup高于服务进程，则设置为该值</li>
      <li>当cpr.hasExternalProcessHandles为true的情况</li>
      <li>最后，当maxAdj &lt;= PERCEPTIBLE_APP_ADJ的情况</li>
    </ul>
  </li>
</ul>

<h4 id="threadgroupbgnoninteractive">THREAD_GROUP_BG_NONINTERACTIVE<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#threadgroupbgnoninteractive" aria-label="Anchor link for: threadgroupbgnoninteractive" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<ul>
  <li>SCHED_GROUP_BACKGROUND:
    <ul>
      <li>应用已结束(app.thread == null)</li>
      <li>正在接收来自于mBgBroadcastQueue广播队列的广播；</li>
      <li>正在执行来自于前台调度进程发起的服务(execServicesFg=false)</li>
      <li>TOP_APP，且设备处于睡眠状态</li>
      <li>等等</li>
    </ul>
  </li>
</ul>

<h3 id="section-6">命令<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#section-6" aria-label="Anchor link for: section 6" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<ul>
  <li>dumpsys meminfo，</li>
  <li>dumpsys activity o</li>
  <li>dumpsys activity p</li>
</ul>

<h2 id="section-7">三、总结<a class="anchorjs-link " href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#section-7" aria-label="Anchor link for: section 7" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h2>

<p>对于处于startRequested状态的进程，也就是执行了startService()且没有stop的进程。</p>

<ul>
  <li>当hasShownUi，则ADJ &gt; SERVICE_ADJ，adjType等于”cch-started-ui-services”;</li>
  <li>当超过30分钟(MAX_SERVICE_INACTIVITY)没有活动过，则ADJ &gt; SERVICE_ADJ，adjType等于”cch-started-services”;</li>
  <li>当既没有UI 也没有超过30分钟，则ADJ = SERVICE_ADJ, adjType等于”started-services”;</li>
</ul>

<p>包括Activity的进程，即便是将Service停止掉，也会被认为是cached进程。由于此类进程占用内存比较大，还是会比较容易杀掉。</p>

<p>进程在启动服务后，在事情做完后，必须呼叫stopService或stopSelf通知框架，避免事情做完了，服务进程依旧常驻内存</p>

<ol>
  <li>对于允许自启动的服务进程，首先要跟UI进程分离，避免占用较大的UI进程常驻于内存；其次尽量不要绑定其他进程的service和provider，使用完后应该立刻释放绑定关系，避免其他进程常驻于内存。</li>
</ol>

<p>5.不可使用SystemUID进程内的provider，在Android设计中，若针对System UID的进程使用provider，即使已关掉provider，但框架仍会保持provider connection</p>

<ol>
  <li>fg-service不可滥用，避免产生非常糟糕的用户体验</li>
</ol>

<p>前台进程与后台进程？是指CPU调度优先级
前台与后台service?
前台广播与后台广播？</p>

<p>启动进程的过程优先级怎么计算的？
刚启动的时候，只有当curAdj和setAdj不相等时才会触发将当前进程以及adj写入lmk节点。
而进程在刚创建之时，ADJ等于INVALID_ADJ(-10000)。只有当attachApplication()执行完成后，才会有真正的adj写入节点。</p>

<ul>
  <li>拥有用户正在交互的 Activity（已调用onResume()）</li>
  <li>拥有某个 Service，后者绑定到用户正在交互的 Activity</li>
  <li>拥有正在“前台”运行的 Service（服务已调用）</li>
  <li>拥有正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）</li>
  <li>拥有正执行其 onReceive() 方法的 BroadcastReceiver</li>
</ul>

<p>内存因子用于
ADJ用于杀进程策略；
SCHED用于CPU调度分配</p>

<ol>
  <li>UI进程与service进程分离</li>
  <li>adj=2，音乐</li>
  <li>A、B Service进程 与内存</li>
  <li>cache与empty上限</li>
  <li>ADJ与CPU调度优先级</li>
  <li>ADJ与LMK</li>
  <li>ADJ=0，生命周期与anr</li>
  <li>ADJ重要性排级别</li>
  <li>ADJ_MEM_FACTOR</li>
</ol>

								<hr>
								<font color="#004B97"><strong>欢迎关注微信公众号:</strong></font>
<a target="_blank" href="http://gityuan.com/images/about-me/damoyuan.jpg">
	<font color="#f57e42"><strong>Android达摩院</strong></font>
</a>

<font color="#004B97"><strong>, 微博:</strong></font>
<a target="_blank" href="http://weibo.com/gityuan">
	<font color="#f57e42"><strong>weibo.com/gityuan </strong></font>
</a>

<font color="#004B97"><strong>！</strong></font>

                <hr>
								

                <ul class="pager">
                    
                    <li class="previous">
                        <a target="_blank" href="http://127.0.0.1:4000/2018/05/12/binder-driver-bug/" data-toggle="tooltip" data-placement="top" title="Binder Driver缺陷导致定屏问题分析">
                        上一篇<br>
                        <span>Binder Driver缺陷导致定屏问题分析</span>
                        </a>
                    </li>
                    
                    
                </ul>


                

            </div>  

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog fixed">
                    <hr class="hidden-sm hidden-xs">
                    <h5 id="catalog">
                        <a class="catalog-toggle" href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"><li class="h2_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#section" rel="nofollow">一、概述</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#section-1" rel="nofollow">1.1 进程</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#section-2" rel="nofollow">1.2 优先级</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#adj" rel="nofollow">1.3 ADJ级别</a></li><li class="h2_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#adj-1" rel="nofollow">二、解读ADJ</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#nativeadj-1000" rel="nofollow">2.1 NATIVE_ADJ(-1000)</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#systemadj-900" rel="nofollow">2.2 SYSTEM_ADJ(-900)</a></li><li class="h4_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#setsystemprocess" rel="nofollow">场景1：setSystemProcess</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#persistentprocadj-800" rel="nofollow">2.3 PERSISTENT_PROC_ADJ(-800)</a></li><li class="h4_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#newprocessrecordlocked" rel="nofollow">场景1：newProcessRecordLocked</a></li><li class="h4_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#addapplocked" rel="nofollow">场景2：addAppLocked</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#persistentserviceadj-700" rel="nofollow">2.4 PERSISTENT_SERVICE_ADJ(-700)</a></li><li class="h4_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#newprocessrecordlocked-1" rel="nofollow">场景1：newProcessRecordLocked</a></li><li class="h4_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#computeoomadjlocked" rel="nofollow">场景2：computeOomAdjLocked</a></li><li class="h4_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#service-flags" rel="nofollow">Service flags解释</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#foregroundappadj0" rel="nofollow">2.5 FOREGROUND_APP_ADJ(0)</a></li><li class="h4_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#computeoomadjlocked-1" rel="nofollow">场景1：computeOomAdjLocked</a></li><li class="h4_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#bindservice" rel="nofollow">场景2：bindService</a></li><li class="h4_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#provider" rel="nofollow">场景3：provider</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#visibleappadj100" rel="nofollow">2.6 VISIBLE_APP_ADJ(100)</a></li><li class="h4_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#section-3" rel="nofollow">场景1</a></li><li class="h4_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#section-4" rel="nofollow">场景2</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#perceptibleappadj200" rel="nofollow">2.7 PERCEPTIBLE_APP_ADJ(200)</a></li><li class="h4_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#activity" rel="nofollow">场景1：Activity状态</a></li><li class="h4_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#fg-service" rel="nofollow">场景2： fg-service</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#backupappadj300" rel="nofollow">8. BACKUP_APP_ADJ(300)</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#heavyweightappadj400" rel="nofollow">9. HEAVY_WEIGHT_APP_ADJ(400)</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#serviceadj500" rel="nofollow">10. SERVICE_ADJ(500)</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#homeappadj600" rel="nofollow">11. HOME_APP_ADJ(600)</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#previousappadj700" rel="nofollow">12. PREVIOUS_APP_ADJ(700)</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#servicebadj800" rel="nofollow">13. SERVICE_B_ADJ(800)</a></li><li class="h4_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#adjmemfactor" rel="nofollow">ADJ_MEM_FACTOR</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#cachedappminadj900" rel="nofollow">14. CACHED_APP_MIN_ADJ(900)</a></li><li class="h2_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#section-5" rel="nofollow">三、查看进程优先级</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#cpu" rel="nofollow">3.1 CPU调度优先级</a></li><li class="h4_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#threadgrouptopapp" rel="nofollow">THREAD_GROUP_TOP_APP</a></li><li class="h4_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#threadgroupdefault" rel="nofollow">THREAD_GROUP_DEFAULT</a></li><li class="h4_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#threadgroupbgnoninteractive" rel="nofollow">THREAD_GROUP_BG_NONINTERACTIVE</a></li><li class="h3_nav"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#section-6" rel="nofollow">命令</a></li><li class="h2_nav active"><a href="http://127.0.0.1:4000/2018/05/19/android-process-adj/#section-7" rel="nofollow">三、总结</a></li></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5 id="featured-tags"><a target="_blank" href="http://127.0.0.1:4000/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#android" title="android" rel="136">
                                    android
                                </a>
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#%E7%BB%84%E4%BB%B6%E7%B3%BB%E5%88%97" title="组件系列" rel="19">
                                    组件系列
                                </a>
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#else" title="else" rel="3">
                                    else
                                </a>
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#debug" title="debug" rel="18">
                                    debug
                                </a>
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#%E6%9D%83%E9%99%90" title="权限" rel="2">
                                    权限
                                </a>
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#web" title="web" rel="2">
                                    web
                                </a>
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#tool" title="tool" rel="12">
                                    tool
                                </a>
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#java" title="java" rel="13">
                                    java
                                </a>
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#performance" title="performance" rel="4">
                                    performance
                                </a>
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#app" title="app" rel="2">
                                    app
                                </a>
                            
        				
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#%E8%BF%9B%E7%A8%8B%E7%B3%BB%E5%88%97" title="进程系列" rel="13">
                                    进程系列
                                </a>
                            
        				
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#memory" title="memory" rel="5">
                                    memory
                                </a>
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#jvm" title="jvm" rel="5">
                                    jvm
                                </a>
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#linux" title="linux" rel="8">
                                    linux
                                </a>
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#binder" title="binder" rel="19">
                                    binder
                                </a>
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#ipc" title="ipc" rel="3">
                                    ipc
                                </a>
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#handler" title="handler" rel="3">
                                    handler
                                </a>
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#process" title="process" rel="6">
                                    process
                                </a>
                            
        				
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8" title="系统启动" rel="6">
                                    系统启动
                                </a>
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#AMS" title="AMS" rel="2">
                                    AMS
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#stability" title="stability" rel="8">
                                    stability
                                </a>
                            
        				
                            
                				<a target="_blank" href="http://127.0.0.1:4000/tags/#%E7%BB%84%E4%BB%B6" title="组件" rel="3">
                                    组件
                                </a>
                            
        				
                            
        				
                            
        				
        			</div>
                </section>
                

                <!-- Friends Blog -->
                <!-- 
                 -->
            </div>
        </div>
    </div>
</article>






<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    <li>
                        <a target="_blank" href="http://weibo.com/gityuan">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/gityuan">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                    
										
                    <li>
                        <a target="_blank" href="https://plus.google.com/101388994961262711072">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-google fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    <li>
                        <a target="_blank" href="http://127.0.0.1:4000/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright © Gityuan  2018 | Powered by Jekyll with Hux Theme
                </p>
                <!-- 流量统计 -->
								<div style="display:none">
									<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000098804'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s22.cnzz.com/z_stat.php%3Fid%3D1000098804%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script><span id="cnzz_stat_icon_1000098804"><a href="http://www.cnzz.com/stat/website.php?web_id=1000098804" target="_blank" title="站长统计"><img border="0" hspace="0" vspace="0" src="./解读Android进程优先级ADJ算法 - Gityuan博客 _ 袁辉辉博客_files/pic.gif"></a></span><script src="./解读Android进程优先级ADJ算法 - Gityuan博客 _ 袁辉辉博客_files/z_stat.php" type="text/javascript"></script><script src="./解读Android进程优先级ADJ算法 - Gityuan博客 _ 袁辉辉博客_files/core.php" charset="utf-8" type="text/javascript"></script>
								</div>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="./解读Android进程优先级ADJ算法 - Gityuan博客 _ 袁辉辉博客_files/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="./解读Android进程优先级ADJ算法 - Gityuan博客 _ 袁辉辉博客_files/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="./解读Android进程优先级ADJ算法 - Gityuan博客 _ 袁辉辉博客_files/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async('/js/jquery.tagcloud.js',function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->




<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>






</body></html>